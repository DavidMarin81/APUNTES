# Verificaci√≥n en dos pasos con email de confirmaci√≥n
## Resumen
- Usuario hace `POST /api/auth/login` con email (o username) + contrase√±a
- Backend valida credenciales. Si OK: genera un c√≥digo aleatorio (6 d√≠gitos), lo guarda temporalmente y lo env√≠a por correo usando `MailKit` + Gmail
- Front pide al usuario el c√≥digo que recibi√≥ por email
- El usuario env√≠a el c√≥digo a `POST /api/auth/verify-2fa-email`. Backend verifica y si coincide, emite sesi√≥n / token

## Crear el proyecto
- Creamos un proyecto ASP.NET Core Web API
- Instalamos MailKit
    ~~~bash
    dotnet add package MailKit
    ~~~

## Configuraci√≥n SMTP en `appsettings.json`
- A√±ade una secci√≥n `EmailSettings`
    ~~~json
    {
    "EmailSettings": {
        "SmtpServer": "smtp.gmail.com",
        "SmtpPort": 587,
        "SenderName": "MiAppSegura",
        "SenderEmail": "tu_correo@gmail.com",
        "Username": "tu_correo@gmail.com",
        "Password": "AQUI_TU_CONTRASE√ëA_DE_APLICACION"
        }
    }
    ~~~
- Importante: esa `Password` debe ser contrase√±a de aplicaci√≥n de Google.
    - Para obtenerla:
        - Hay que tener activa la verificaci√≥n en dos pasos en la cuenta Google
        - Ir aqui üëâ https://myaccount.google.com/apppasswords üëà
        - En "Contrase√±as de aplicaci√≥n" crear una
        - Si ya se cre√≥ una, Google no te deja volver a verla
    - M√°s seguro: en producci√≥n no guardes credenciales en `appsettings.json`. Usa **Secret Manager** (dotnet user-secrets) o variables de entorno / vault

## Crear `EmailService` (Services/EmailService.cs)
- Crea la clase para enviar correos con MailKit
    ~~~csharp
    using MailKit.Net.Smtp;
    using MimeKit;
    using Microsoft.Extensions.Options;
    using System.Threading.Tasks;

    namespace MyApp.Services
    {
        public class EmailSettings
        {
            public string SmtpServer { get; set; } = "";
            public int SmtpPort { get; set; } = 587;
            public string SenderName { get; set; } = "";
            public string SenderEmail { get; set; } = "";
            public string Username { get; set; } = "";
            public string Password { get; set; } = "";
        }

        public class EmailService
        {
            private readonly EmailSettings _settings;

            public EmailService(IOptions<EmailSettings> settings)
            {
                _settings = settings.Value;
            }

            public async Task SendEmailAsync(string to, string subject, string body)
            {
                var message = new MimeMessage();
                message.From.Add(new MailboxAddress(_settings.SenderName, _settings.SenderEmail));
                message.To.Add(MailboxAddress.Parse(to));
                message.Subject = subject;
                message.Body = new TextPart("plain") { Text = body };

                using var client = new SmtpClient();
                await client.ConnectAsync(_settings.SmtpServer, _settings.SmtpPort, MailKit.Security.SecureSocketOptions.StartTls);
                await client.AuthenticateAsync(_settings.Username, _settings.Password);
                await client.SendAsync(message);
                await client.DisconnectAsync(true);
            }
        }
    }
    ~~~

## Registrar `EmailService` en `Program.cs`
- En `Program.cs` a√±ade:
    ~~~csharp
    builder.Services.Configure<MyApp.Services.EmailSettings>(
        builder.Configuration.GetSection("EmailSettings")
    );
    builder.Services.AddSingleton<MyApp.Services.EmailService>();
    ~~~
- Y si usas DI con interfaces, podr√≠as registrar `IEmailService`

## Modelos y DTOs
- Crea `Models/User.cs` (temporal: lista en memoria para pruebas)
    ~~~csharp
    namespace MyApp.Models
    {
        public class User
        {
            public string Username { get; set; } = ""; // aqu√≠ usaremos el email como username si quieres
            public string Password { get; set; } = ""; // EN PRODUCCI√ìN: guarda hash, nunca plain
            public string TwoFactorSecret { get; set; } = ""; // opcional si mezclas TOTP + email
        }
    }
    ~~~
- DTO para verificaci√≥n 
    ~~~csharp
    namespace MyApp.DTO
    {
        public class VerifyUserDTO
        {
            public string Username { get; set; } = "";
            public string Code { get; set; } = "";
        }
    }
    ~~~

## L√≥gica de 2FA por email en `AuthController`
- Crea `Controllers/AuthController.cs`
    ~~~csharp
    using Microsoft.AspNetCore.Mvc;
    using MyApp.Models;
    using MyApp.DTO;
    using MyApp.Services;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using System.Security.Cryptography;

    namespace MyApp.Controllers
    {
        [ApiController]
        [Route("api/[controller]")]
        public class AuthController : ControllerBase
        {
            // Simula DB en memoria (solo para pruebas)
            private static List<User> Users = new()
            {
                // Usuario de ejemplo (en producci√≥n: crea endpoint /register)
                new User { Username = "usuario@ejemplo.com", Password = "1234" }
            };

            // { username -> (code, expiresAt, attempts) }
            private static Dictionary<string, (string Code, DateTime ExpiresAt, int Attempts)> EmailCodes = new();

            private readonly EmailService _emailService;

            public AuthController(EmailService emailService)
            {
                _emailService = emailService;
            }

            [HttpPost("login")]
            public async Task<IActionResult> Login([FromBody] User login)
            {
                var found = Users.FirstOrDefault(u => u.Username == login.Username && u.Password == login.Password);
                if (found == null)
                    return Unauthorized("Credenciales inv√°lidas");

                // Generar c√≥digo seguro de 6 d√≠gitos
                string code = GenerateNumericCode(6);
                var expires = DateTime.UtcNow.AddMinutes(5);

                // Guardar (sobrescribe si exist√≠a)
                EmailCodes[found.Username] = (code, expires, 0);

                // Enviar correo
                var body = $"Tu c√≥digo de verificaci√≥n es: {code}\nCaduca en 5 minutos.";
                await _emailService.SendEmailAsync(found.Username, "C√≥digo de verificaci√≥n 2FA", body);

                return Ok(new { requires2FA = true, message = "Se ha enviado un c√≥digo al correo." });
            }

            [HttpPost("verify-2fa-email")]
            public IActionResult Verify2FAEmail([FromBody] VerifyUserDTO data)
            {
                if (!EmailCodes.ContainsKey(data.Username))
                    return BadRequest("No se ha solicitado verificaci√≥n o ya expir√≥.");

                var entry = EmailCodes[data.Username];

                if (DateTime.UtcNow > entry.ExpiresAt)
                {
                    EmailCodes.Remove(data.Username);
                    return Unauthorized("El c√≥digo ha expirado.");
                }

                // Limitar intentos bruteforce
                if (entry.Attempts >= 5)
                {
                    EmailCodes.Remove(data.Username);
                    return Unauthorized("Demasiados intentos. Vuelve a iniciar sesi√≥n.");
                }

                if (data.Code != entry.Code)
                {
                    // incrementar contador de intentos
                    EmailCodes[data.Username] = (entry.Code, entry.ExpiresAt, entry.Attempts + 1);
                    return Unauthorized("C√≥digo incorrecto.");
                }

                // OK: eliminar el c√≥digo y devolver token / √©xito
                EmailCodes.Remove(data.Username);

                // Aqu√≠ deber√≠as crear tu token JWT o sesi√≥n
                return Ok(new { success = true, message = "Verificaci√≥n completada ‚úÖ" });
            }

            // M√©todo helper: generar c√≥digo num√©rico seguro
            private static string GenerateNumericCode(int digits)
            {
                using var rng = RandomNumberGenerator.Create();
                var bytes = new byte[4];
                rng.GetBytes(bytes);
                uint value = BitConverter.ToUInt32(bytes, 0) % (uint)Math.Pow(10, digits);
                return value.ToString().PadLeft(digits, '0');
            }
        }
    }
    ~~~
- Notas:
    - `GenerateNumericCode` usa `RandomNumberGenerator` (crYPTO-saudable), mejor que `Random`
    - Se almacena en memoria en `EmailCodes` con expiraci√≥n y contador de intentos
    - En producci√≥n usa cache (IMemoryCache) o DB (Redis) para persistir/expirar c√≥digos
    - En `Login` se env√≠a el correo con `_emailService.SendEmailAsync`

## Probar el backend localmente
- Ejecuta la API en Visual Studio
- Usa Postman o Swagger para probar
- `POST /api/auth/login` body:
    ~~~json
    {
        "username": "usuario@ejemplo.com",
        "password": "1234"
    }
    ~~~
- Respuesta esperada: `{ requires2FA: true, message: "Se ha enviado..."}` y el correo llega
- `POST /api/auth/verify-2fa-email` body:
    ~~~json
    {
        "username": "usuario@ejemplo.com",
        "code": "123456"
    }
    ~~~

## Adapta tu frontend React 
- Login env√≠a credenciales y espera `requires2FA`
    ~~~js
    // handleLogin()
    const res = await fetch("/api/auth/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ Username: email, Password: password })
    });
    if (!res.ok) {
    const text = await res.text();
    setLoginMsg(text);
    return;
    }
    const data = await res.json();
    if (data.requires2FA) {
    setLoginMsg("C√≥digo enviado a tu correo. Introduce el c√≥digo.");
    setRequires2FA(true);
    }
    ~~~
- Verificar c√≥digo
    ~~~js
    // handleVerify2FA()
    const res = await fetch("/api/auth/verify-2fa-email", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ Username: email, Code: codeInput })
    });
    if (!res.ok) {
    const text = await res.text();
    setMsg2FA(text);
    return;
    }
    const data = await res.json();
    if (data.success) {
    // login completado -> guardar token / redirigir
    navigate("/Inicio");
    }
    ~~~

## Buenas pr√°cticas
- Nunca guardes contrase√±as en texto plano en producci√≥n. Usa hashing (BCrypt, Argon2)
- Usa HTTPS tanto en API como en el front
- No guardes credenciales SMTP en `appsettings.json` en repositorio. Usa **user-secrets** durante desarrollo y variables de entorno en producci√≥n
- Limita intentos para evitar **ataques de fuerza bruta** (por usuario y por IP)
- C√≥digo de verificaci√≥n: caducidad corta (3 - 10 minutos), y un m√°ximo de intentos (3-5)
- Para env√≠os a gran escala o producci√≥n, usa proveedores especializados (SendGrid, Mailgun, Amazon SES)
- A√±ade logs y monitorizaci√≥n de env√≠os fallidos
